\chapter{Introduction}

\section{Current results}

In this section we will explore the current state of the complexity analysis as $r$ and $\ell$ grows. As we fullfill the following table we expose the strategies and how those can be used to enlight the more complex results.

The most trivial result is the recognition of the $(1,0)$-graphs, as in order to recognize it we just need to know if $|E(G)| > 0$. Therefore it's complexity is \O{1}.

\begin{table}[h!]
  \caption{Incomplete complexity analysis of the \RL-partite recognition problem}
  \label{}
  \center
  \begin{tabular}{l|*{6}c}
    \toprule
    \backslashbox{$r$}{$\ell$} & 0 & 1 & 2 & 3 & 4 & \ldots \\
    \midrule
    0 & -  & \? & \? & \? & \? & \ldots \\
    1 & \O{1} & \? & \? & \? & \? & \ldots \\
    2 & \? & \? & \? & \? & \? & \ldots \\
    3 & \? & \? & \? & \? & \? & \ldots \\
    4 & \? & \? & \? & \? & \? & \ldots \\
    $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\ddots$ \\
  \end{tabular}
\end{table}

\subsection{$m$-bounded results}

Naturally, we wish to find the complexity for those problems of small partition cardinality.

At \cite{konig36}, König showed that it takes \O{m} steps to recognize a bipartite graph. For complete graphs, is enough to check if $|E(G)|=n(n-1)/2$, if it doesn't then we have an answer; If it does, checking vertex by vertex if it's neighborhood contains all other vertex is \O{m}.

For co-bipartite graphs recognition, we need only to verify if it's complement is a bipartite graph. The recognition of a split graph can be done using their vertex degrees \cite{??}, obtaining all vertices degrees is \O{m} therefore the recognition of split graphs is \O{m}
% \begin{table}[h!]
%   \caption{Incomplete complexity analysis of the \RL-partite recognition problem}
%   \label{}
%   \center
%   \begin{tabular}{l|*{6}c}
%     \toprule
%     \backslashbox{$r$}{$\ell$} & 0 & 1 & 2 & 3 & 4 & \ldots \\
%     \midrule
%     0 & -  & \O{m} & \O{m} & \? & \? & \ldots \\
%     1 & \O{1} & \O{m} & \? & \? & \? & \ldots \\
%     2 & \O{m} & \? & \? & \? & \? & \ldots \\
%     3 & \? & \? & \? & \? & \? & \ldots \\
%     4 & \? & \? & \? & \? & \? & \ldots \\
%     $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\ddots$ \\
%   \end{tabular}
% \end{table}

\subsection{$NP$-Complete results}

An adequate strategy at this moment is to find when the recognition problem gets $NP$-Complete.

At \cite{gareyjohnson} is shown that 3-coloring a graph (i.e. assign a color between three possibles to each vertex such that no neighborhood repeats a color) is $NP$-Complete, it's trivial to see how the 3-coloring of a graph can be reduced to the problem of finding if a graph is a $(3,0)$-graph, therefore the recognition of $(3,0)$-graphs is $NP$-Complete.

It's noticible that the recognition of \RL-graphs is monotonic, and therefore if the recognition of $(3,0)$-graphs are $NP$-Complete then the recognition of any $(r,0)$-graph or $(3,\ell)$-graph is $NP$-Complete for $r > 3$ and $\ell >0$.

We can extrapolate these findings and argument that the recognition of a $(0,3)$-graph is also $NP$-Complete, as it is the same as recognize it's complement as a $(3,0)$-graph, and use the property of monotonicity to state that the recognition of any $(r,3)$-graph or $(0,\ell)$-graph is $NP$-Complete for $r > 0$ and $\ell >3$.

\begin{table}[h!]
  \caption{Incomplete complexity analysis of the \RL-partite recognition problem}
  \label{}
  \center
  \begin{tabular}{l|*{6}c}
    \toprule
    \backslashbox{$r$}{$\ell$} & 0 & 1 & 2 & 3 & 4 & \ldots \\
    \midrule
    0 & -  & \O{m} & \O{m} & \NPc & \NPc & \ldots \\
    1 & \O{1} & \O{m} & \? & \NPc & \NPc & \ldots \\
    2 & \O{m} & \? & \? & \NPc & \NPc & \ldots \\
    3 & \NPc & \NPc & \NPc & \NPc & \NPc & \ldots \\
    4 & \NPc & \NPc & \NPc & \NPc & \NPc & \ldots \\
    $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\ddots$ \\
  \end{tabular}
\end{table}

\subsection{Frontier results}

Finally, the frontier cases $(1,2)$,$(2,1)$ and $(2,2)$ were subject of studies by Brandstädt\cite{brand-84,brand-96}. He's findings show that:
\begin{itemize}
  \item Recognition of $(1,2)$-graphs are \O{n^4}.
  \item Recognition of $(2,1)$-graphs are \O{n^4}.
  \item Recognition of $(2,2)$-graphs are \O{n^{12}}.
\end{itemize}

\begin{table}[h!]
  \caption{Current complexity analysis of the \RL-partite recognition problem}
  \label{table:current-values}
  \center
  \begin{tabular}{l|*{6}c}
    \toprule
    \backslashbox{$r$}{$\ell$} & 0 & 1 & 2 & 3 & 4 & \ldots \\
    \midrule
    0 & -  & \O{m} & \O{m} & \NPc & \NPc & \ldots \\
    1 & \O{1} & \O{m} & \O{n^4} & \NPc & \NPc & \ldots \\
    2 & \O{m} & \O{n^4} & \O{n^{12}} & \NPc & \NPc & \ldots \\
    3 & \NPc & \NPc & \NPc & \NPc & \NPc & \ldots \\
    4 & \NPc & \NPc & \NPc & \NPc & \NPc & \ldots \\
    $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\ddots$ \\
  \end{tabular}
\end{table}

\section{Brandstädt's recognition of $(2,1)$-graphs}

In this section we will describe the algorithm designed by Brandstädt to recognize a $(2,1)$-graph.

Let $G$ be a graph. In order for $G$ to accept a $(2,1)$-partition a necessary condition is that for any vertex $v \in V(G)$:

\begin{itemize}
\item (N1) $N(v)$ induces a split graph.
\item (N2) Or, $\bar{N}(v)$ should induces a bipartite graph
\end{itemize}

More specifically, if $G$ has a $(2,1)$-partition $I_1,I_2,C$ then (N2) holds for every vertex $v \in C$ and (N1) holds for the vertices $v \in I_1 \cup I_2$

Let A be the set of vertices that is satisfied by (N1), let B be the set o vertices satisfied by (N2) then if $R=A \cap B=\emptyset$ then we already have a $(2,1)$-partition of G. Otherwise 



This conditions leads us to the following algorithm:


\begin{code}{Get (2,1)-partition}
  def Get_21(Graph G) 2-1-Partition
    for v in V(G) do
      N = |$N(v)$| # open neighboorhood of v
      K = |$\bar{N}(v)$| # V(G) - N
      if (!N.is_Split() and !K.is_Bipartite()) then
        return None; # G $\notin$ (2,1)
    end
    cl = { v in V(G) : !|$N(v)$|.is_Split() and |$\bar{N}(v)$|.is_Bipartite() }
    bi = { v in V(G) : |$N(v)$|.is_Split() and !|$\bar{N}(v)$|.is_Bipartite() }
    if ( !cl.is_Clique() or !bi.is_Bipartite()) then
      return None; # G $\notin$ (2,1)
    R = {v in V(G) : |$N(v)$|.is_Split() and |$\bar{N}(v)$|.is_Bipartite()}
    if R.is_Empty() then
      return new 2-1-Partition {
        |$I_1$|: bi.|$I_1$|,
        |$I_2$|: bi.|$I_2$|,
        |$C$|: cl
      }
    else return AllocateR(bi,cl,R)
  end
\end{code}

\begin{code}{AllocateR}
  def AllocateR(bi Bipartite, cl Clique, R Graph)
    if R.is_Split() then
      

\end{code}

\begin{code}{My Code}
def Get_21(Graph G) 2-1-Partition
  cl = new Graph #intended clique
  bi = new Graph #intended bipartite 
  for v in V(G) do # $\O{n}$
      N = |$N(v)$| # open neighboorhood of v
      K = |$\bar{N}(v)$| # V(G) - N
      if N.is_Split() then # $\O{m}$
        bi.Add(v)
      if K.is_Bipartite() then # $\O{m}$
        cl.Add(v)
      if (!bi.contains(v) and !cl.contains(v)) then
       return None; # G $\notin$ (2,1)
  end # $\O{n*m}$
  if |$cl.V \cap bi.V = \emptyset$| then
    if (!cl.is_Clique() or !bi._is_Bipatite()) then
      return None; # G $\notin$ (2,1)
    else return new 2-1-patition{
      |$C$|: cl
      |$I_1$|: bi.|$I_1$|,
      |$I_2$|: bi.|$I_2$|
    }
  else 
    using any |$v \in cl.V \cap bi.V$|
    N = |$N(v)$| # open neighboorhood of v
    K = |$\bar{N}(v)$| # V(G) - N
    tr = new 3-1-Partition{
          |$C$|: N.Clique,
          |$I_1$|: N.Independent,
          |$I_2$|: K.|$I_1$|,
          |$I_3$|: K.|$I_2$|,
    }
    return 3-1-to-2-1(tr)
  end
end
\end{code}

\begin{code}{3-1-to-2-1}
def 3-1-to-2-1(Graph-3-1 G)
  tri = |$G.I_1 \cup G.I_2 \cup G.I_3$| 
  oct = Odd-Cycle-Transversal(tri,3)
  case oct is None then
    return None; # There's more then 3 vertices in the tripartite that should move.
  case oct = 1 then
    for v in tri.v do
      inter = |$\bar{N}(v) \cap G.C$|
      if size(inter) > 2 then
        break loop; 
      cl = G.C - inter + v
      bi = tri - v + inter
      if (cl.is_Clique() and bi.is_Bipartite()) then
        return new 2-1-patition{
          |$C$|: cl
          |$I_1$|: bi.|$I_1$|,
          |$I_2$|: bi.|$I_2$|
        }
      end
    end
    return None; # There's no vertice that can be moved.
  case oct = 2 then
    return Transform2(tri,G.C)
  case oct = 3 then
    for v in oct do
      inter = |$\bar{N}(v) \cap G.C$|
      if size(inter) > 2 then
        break loop; 
      cl = G.C - inter + v
      neoTri = tri - v + inter
      result = Transform2(neoTri,cl)
      if result is not None then
        return result;
    end
    return None; 
\end{code}

% A `false` return from the algorithm described above, doesn't indicates that the graph is a $(2,1)$-graph, but raises a interesting condition.

% Let $A$ be the set of vertices that posses the property where it's open neighborhood($N$) induces a split graph in $G$, and $B$ the set of vertices that the not-neighborhood induces a bipartite graph. If $A \cap B = \emptyset$ then the graph is a $(2,1)$-graph; Otherwise the graph is guarantee to be a $(3,1)$-graph, since there's a vertex which is capable of delimiting 3 disjointed stable sets (Both from the one induced by the not-neighborhood and the on induced by the neighborhood) and a clique (induced by the neighborhood). Then the remaining work shall be to determine if the $(3,1)$-graph is a $(2,1)$-graph.

% \begin{code}{Get a (3,1)-partition}
%   def get_31(Graph G) 3-1-Partition
%     for v in V(G) do
%       N = open_neighborhood(v)
%       K = V(G) - N
%       if (is_Split(N) and is_Bipartite(K))
%         return new 3-1-Partition{
%           R1: K.R1,
%           R2: K.R2,
%           R3: N.R,
%           L: N.L
%           };
%     end
%     return empty31();
%   end
% \end{code}
